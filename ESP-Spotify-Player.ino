/*ESP Spotify Player V1
- By Kaustubh Doval

OLED: 128x64
  SCK -> D22
  SDA -> D21

Buttons
  previous button   -> D5
  play/pause button -> D18
  next button       -> D19

Rotary Encoder
  CLK -> D4
  DT  -> D2
  SW  -> D15

SETUP:
(1) Change SSID and Password (line 45)
(2) Change Client Secret and ID (49)
(3) Run the program, You can see your ESPs IP on Serial Monitor (9600 Baud Rate) and on the OLED.
    You need to add the IP address of your ESP to REDIRECT_URI definition (line 51):
          http://YOUR_ESP_IP/callback
(4) Add this callback to Spotify Web API portal as well (ensure that it is exactly the same as REDIRECT_URI)
(5) You are good to go!
*/
#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SH110X.h>
#include <ESP32Encoder.h>
#include <ArduinoJson.h>
#include <base64.h>
#include <ezButton.h>

// Include WiFi and http client
#include <WiFi.h>
#include <HTTPClient.h>
#include <WebServer.h>
#include <WiFiClientSecure.h>

// Load tabs attached to this sketch
#include "index.h"

// WiFi credentials
#define WIFI_SSID "WIFI_SSID"
#define PASSWORD "WIFI_PASSWORD"

// Spotify API credentials
#define CLIENT_ID "SPOTIFY_CLIENT_ID"
#define CLIENT_SECRET "SPOTIFY_CLIENT_SECRET"
#define REDIRECT_URI "http://YOUR_ESP_IP/callback"

// Pin Definitions
#define PREV_BTN_PIN 5
#define PLAY_BTN_PIN 18
#define NEXT_BTN_PIN 19
#define ENC_CLK_PIN 4
#define ENC_DT_PIN 2
#define ENC_SW_PIN 15

// OLED Definitions
#define I2C_ADDRESS 0x3c
#define SCREEN_WIDTH 128
#define SCREEN_HEIGHT 64
#define OLED_RESET -1

// Timing constants
#define API_REFRESH_INTERVAL 5000 // 5 seconds
#define VOLUME_UPDATE_THRESHOLD 2 // Minimum volume change to update

// Some Bitmap Definitions
static const unsigned char PROGMEM no_active_device[] = {0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x01, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x01, 0xe0, 0x07, 0xce, 0x78, 0x03, 0x80, 0x00, 0x41, 0x02, 0x00, 0x01, 0x00, 0x7c, 0x01, 0xe0, 0x04, 0x11, 0x44, 0x04, 0x40, 0x00, 0x40, 0x05, 0x00, 0x01, 0x00, 0x44, 0x01, 0xe0, 0x04, 0x10, 0x44, 0x04, 0x16, 0x39, 0xf3, 0x04, 0x44, 0x01, 0x00, 0x7c, 0x01, 0xe0, 0x07, 0x8e, 0x78, 0x03, 0x99, 0x44, 0x41, 0x0e, 0x44, 0x01, 0x00, 0x7c, 0x01, 0xe0, 0x04, 0x01, 0x40, 0x00, 0x59, 0x44, 0x41, 0x04, 0x3c, 0x01, 0x00, 0x7c, 0x01, 0xe0, 0x04, 0x11, 0x40, 0x04, 0x56, 0x44, 0x51, 0x04, 0x04, 0x01, 0x00, 0x00, 0x01, 0xe0, 0x07, 0xce, 0x40, 0x03, 0x90, 0x38, 0x23, 0x84, 0x44, 0x01, 0x00, 0x00, 0x01, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x38, 0x01, 0x1f, 0xff, 0x9f, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x10, 0x00, 0x91, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf0, 0x00, 0xf1, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x01, 0xe0, 0x00, 0x00, 0x0f, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x7c, 0x01, 0xe0, 0x00, 0x00, 0x08, 0x88, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x7c, 0x01, 0xe0, 0x00, 0x00, 0x08, 0x88, 0x62, 0x27, 0x2c, 0x00, 0x00, 0x01, 0x00, 0x7c, 0x01, 0xe0, 0x00, 0x00, 0x0f, 0x08, 0x12, 0x28, 0xb2, 0x00, 0x00, 0x01, 0x00, 0x44, 0x01, 0xe0, 0x00, 0x00, 0x08, 0x08, 0x71, 0xef, 0xa0, 0x00, 0x00, 0x01, 0x00, 0x7c, 0x01, 0xe0, 0x00, 0x00, 0x08, 0x08, 0x90, 0x28, 0x20, 0x00, 0x00, 0x01, 0x00, 0x00, 0x01, 0xe0, 0x00, 0x00, 0x08, 0x1c, 0x7a, 0x27, 0x20, 0x00, 0x00, 0x01, 0x00, 0x00, 0x01, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x01, 0xc0, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xfe, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xfc, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x20, 0x02, 0x08, 0x00, 0x00, 0x3c, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x50, 0x02, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x27, 0x00, 0x89, 0xcf, 0x98, 0x89, 0xc0, 0x22, 0x72, 0x26, 0x1c, 0x70, 0x00, 0x02, 0xa8, 0x80, 0x8a, 0x22, 0x08, 0x8a, 0x20, 0x22, 0x8a, 0x22, 0x22, 0x88, 0x00, 0x02, 0x68, 0x80, 0xfa, 0x02, 0x08, 0x8b, 0xe0, 0x22, 0xfa, 0x22, 0x20, 0xf8, 0x00, 0x02, 0x28, 0x80, 0x8a, 0x22, 0x88, 0x52, 0x00, 0x22, 0x81, 0x42, 0x22, 0x80, 0x00, 0x02, 0x27, 0x00, 0x89, 0xc1, 0x1c, 0x21, 0xc0, 0x3c, 0x70, 0x87, 0x1c, 0x70, 0x00};
static const unsigned char PROGMEM splash_screen[] = {0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x01, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x01, 0xe0, 0x07, 0xce, 0x78, 0x03, 0x80, 0x00, 0x41, 0x02, 0x00, 0x01, 0x00, 0x7c, 0x01, 0xe0, 0x04, 0x11, 0x44, 0x04, 0x40, 0x00, 0x40, 0x05, 0x00, 0x01, 0x00, 0x44, 0x01, 0xe0, 0x04, 0x10, 0x44, 0x04, 0x16, 0x39, 0xf3, 0x04, 0x44, 0x01, 0x00, 0x7c, 0x01, 0xe0, 0x07, 0x8e, 0x78, 0x03, 0x99, 0x44, 0x41, 0x0e, 0x44, 0x01, 0x00, 0x7c, 0x01, 0xe0, 0x04, 0x01, 0x40, 0x00, 0x59, 0x44, 0x41, 0x04, 0x3c, 0x01, 0x00, 0x7c, 0x01, 0xe0, 0x04, 0x11, 0x40, 0x04, 0x56, 0x44, 0x51, 0x04, 0x04, 0x01, 0x00, 0x00, 0x01, 0xe0, 0x07, 0xce, 0x40, 0x03, 0x90, 0x38, 0x23, 0x84, 0x44, 0x01, 0x00, 0x00, 0x01, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x38, 0x01, 0x1f, 0xff, 0x9f, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x10, 0x00, 0x91, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf0, 0x00, 0xf1, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x01, 0xe0, 0x00, 0x00, 0x0f, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x7c, 0x01, 0xe0, 0x00, 0x00, 0x08, 0x88, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x7c, 0x01, 0xe0, 0x00, 0x00, 0x08, 0x88, 0x62, 0x27, 0x2c, 0x00, 0x00, 0x01, 0x00, 0x7c, 0x01, 0xe0, 0x00, 0x00, 0x0f, 0x08, 0x12, 0x28, 0xb2, 0x00, 0x00, 0x01, 0x00, 0x44, 0x01, 0xe0, 0x00, 0x00, 0x08, 0x08, 0x71, 0xef, 0xa0, 0x00, 0x00, 0x01, 0x00, 0x7c, 0x01, 0xe0, 0x00, 0x00, 0x08, 0x08, 0x90, 0x28, 0x20, 0x00, 0x00, 0x01, 0x00, 0x00, 0x01, 0xe0, 0x00, 0x00, 0x08, 0x1c, 0x7a, 0x27, 0x20, 0x00, 0x00, 0x01, 0x00, 0x00, 0x01, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x01, 0xc0, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xfe, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xfc, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x02, 0x20, 0x00, 0x00, 0x80, 0x20, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x80, 0x02, 0x40, 0x00, 0x00, 0x80, 0x20, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0xa2, 0x02, 0x86, 0x22, 0x7b, 0xe8, 0xac, 0xb0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x22, 0x03, 0x01, 0x22, 0x80, 0x88, 0xb2, 0xc8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x9e, 0x02, 0x87, 0x22, 0x70, 0x88, 0xa2, 0x88, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x82, 0x02, 0x49, 0x26, 0x08, 0xa9, 0xb2, 0x88, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x22, 0x02, 0x27, 0x9a, 0xf0, 0x46, 0xac, 0x88, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
static const unsigned char PROGMEM configuring[] = {0x80, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc1, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x42, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0x8c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0x0c, 0x07, 0x00, 0x00, 0x42, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x0a, 0xb4, 0x08, 0x80, 0x00, 0xa0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x48, 0x08, 0x1c, 0xb0, 0x86, 0x1c, 0x8a, 0xc6, 0x2c, 0x70, 0x00, 0x00, 0x05, 0xf0, 0x08, 0x22, 0xc9, 0xc2, 0x26, 0x8b, 0x22, 0x32, 0x98, 0x00, 0x00, 0x0b, 0x00, 0x08, 0x22, 0x88, 0x82, 0x26, 0x8a, 0x02, 0x22, 0x98, 0x00, 0x00, 0x14, 0xe0, 0x08, 0xa2, 0x88, 0x82, 0x1a, 0x9a, 0x02, 0x22, 0x68, 0xc3, 0x0c, 0x29, 0xb0, 0x07, 0x1c, 0x88, 0x87, 0x02, 0x6a, 0x07, 0x22, 0x08, 0xc3, 0x0c, 0x50, 0xd8, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00, 0xa0, 0x6c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x34, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};

// Create OLED Object
Adafruit_SH1106G display = Adafruit_SH1106G(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);

// Rotary Encoder Object
ESP32Encoder encoder;

// Wifi Objects
WiFiClientSecure secureClient;
HTTPClient https;
WebServer server(80);

// Button Objects
ezButton prevBtn(PREV_BTN_PIN);
ezButton playBtn(PLAY_BTN_PIN);
ezButton nextBtn(NEXT_BTN_PIN);
ezButton encSwBtn(ENC_SW_PIN);

// Timing variables
unsigned long lastApiRefresh = 0;

// Song details struct
struct SongDetails
{
  int durationMs;
  String album;
  String artist;
  String song;
  String Id;
  bool isLiked;
};

// Forward declarations
String truncateString(const String &input, int maxLength);
void handleButtons();
void handleVolumeControl();
void handleRoot();
void handleCallbackPage();

// Spotify Connection Class
class SpotConn
{
public:
  SpotConn()
  {
    secureClient.setInsecure();
    secureClient.setTimeout(10000); // 10 second timeout
  }

  bool getUserCode(const String &serverCode)
  {
    JsonDocument doc;

    https.begin(secureClient, "https://accounts.spotify.com/api/token");
    String auth = "Basic " + base64::encode(String(CLIENT_ID) + ":" + String(CLIENT_SECRET));
    https.addHeader("Authorization", auth);
    https.addHeader("Content-Type", "application/x-www-form-urlencoded");

    String requestBody = "grant_type=authorization_code&code=" + serverCode + "&redirect_uri=" + String(REDIRECT_URI);
    int httpResponseCode = https.POST(requestBody);

    if (httpResponseCode == HTTP_CODE_OK)
    {
      String response = https.getString();
      DeserializationError error = deserializeJson(doc, response);

      if (error)
      {
        Serial.print("JSON parse failed: ");
        Serial.println(error.c_str());
        https.end();
        return false;
      }

      accessToken = doc["access_token"].as<String>();
      refreshToken = doc["refresh_token"].as<String>();
      tokenExpireTime = doc["expires_in"].as<int>();
      tokenStartTime = millis();
      accessTokenSet = true;

      Serial.println("Access token: " + accessToken);
      Serial.println("Refresh token: " + refreshToken);
    }
    else
    {
      Serial.print("ERROR WHILE GETTING USER CODE: ");
      Serial.println(httpResponseCode);
      Serial.println(https.getString());
      https.end();
      return false;
    }

    https.end();
    return accessTokenSet;
  }

  bool refreshAuth()
  {
    JsonDocument doc;

    https.begin(secureClient, "https://accounts.spotify.com/api/token");
    String auth = "Basic " + base64::encode(String(CLIENT_ID) + ":" + String(CLIENT_SECRET));
    https.addHeader("Authorization", auth);
    https.addHeader("Content-Type", "application/x-www-form-urlencoded");

    String requestBody = "grant_type=refresh_token&refresh_token=" + refreshToken;
    int httpResponseCode = https.POST(requestBody);

    accessTokenSet = false;

    if (httpResponseCode == HTTP_CODE_OK)
    {
      String response = https.getString();
      DeserializationError error = deserializeJson(doc, response);

      if (error)
      {
        Serial.print("JSON parse failed: ");
        Serial.println(error.c_str());
        https.end();
        return false;
      }

      accessToken = doc["access_token"].as<String>();

      // If refresh_token is present, update it
      if (!doc["refresh_token"].isNull())
      {
        refreshToken = doc["refresh_token"].as<String>();
      }

      tokenExpireTime = doc["expires_in"].as<int>();
      tokenStartTime = millis();
      accessTokenSet = true;

      Serial.println("Refreshed access token: " + accessToken);
    }
    else
    {
      Serial.print("Error refreshing token: ");
      Serial.println(httpResponseCode);
      Serial.println(https.getString());
      https.end();
      return false;
    }

    https.end();
    return accessTokenSet;
  }

  bool getTrackInfo()
  {
    JsonDocument doc;

    https.useHTTP10(true);
    https.begin(secureClient, "https://api.spotify.com/v1/me/player");
    https.addHeader("Authorization", "Bearer " + accessToken);

    int httpResponseCode = https.GET();
    bool success = false;

    if (httpResponseCode == 200)
    {
      // Serial.println("JSON response received:");
      String input = https.getString();
      DeserializationError error = deserializeJson(doc, input);

      if (error)
      {
        Serial.print(F("deserializeJson() failed: "));
        Serial.println(error.f_str());
        return false;
      }

      // DEVICE INFO
      if (!doc["device"].isNull())
      {
        JsonObject device = doc["device"];
        isActive = device["is_active"].as<bool>();
        volCtrl = device["supports_volume"].as<bool>();
        volume = device["volume_percent"].as<int>();

        Serial.print("Spotify Status: ");
        Serial.println(isActive);
      }
      else
      {
        Serial.println("Device info missing.");
      }

      // PROGRESS
      if (doc["progress_ms"].is<int>())
      {
        currentSongPositionMs = doc["progress_ms"].as<int>(); // NOT float!
      }
      else
      {
        currentSongPositionMs = 0;
      }

      // SONG ITEM
      if (!doc["item"].isNull())
      {
        JsonObject item = doc["item"];

        // ARTIST NAME
        if (!item["artists"].isNull())
        {
          JsonArray artists = item["artists"].as<JsonArray>();
          if (!artists.isNull() && artists.size() > 0)
          {
            currentSong.artist = artists[0]["name"].as<String>();
          }
          else
          {
            currentSong.artist = "Unknown Artist";
          }
        }
        else
        {
          currentSong.artist = "Unknown Artist";
        }

        // SONG NAME
        currentSong.song = item["name"].as<String>();

        // SONG DURATION
        currentSong.durationMs = item["duration_ms"].as<int>();

        // SONG ID
        String songId = item["uri"].as<String>();
        if (songId.startsWith("spotify:track:"))
        {
          songId = songId.substring(14); // Strip "spotify:track:"
        }
        currentSong.Id = songId;
      }
      else
      {
        // Default values if no item
        currentSong.artist = "Unknown Artist";
        currentSong.song = "No Song Playing";
        currentSong.durationMs = 0;
        currentSong.Id = "";
      }

      // PLAYBACK STATE
      if (doc["is_playing"].is<bool>())
      {
        isPlaying = doc["is_playing"].as<bool>();
      }
      else
      {
        isPlaying = false;
      }

      lastSongPositionMs = currentSongPositionMs;
      success = true;

      // Serial.println("Current song: " + currentSong.song);
      // Serial.println("Current artist: " + currentSong.artist);
    }
    else if (httpResponseCode == 204)
    {
      // No content, no active device or no song playing
      Serial.println("NOTE: No Active Device or No Song Playing.");
      isActive = false;
      volCtrl = false;
      success = true;
    }
    else
    {
      Serial.print("Error getting track info: ");
      Serial.println(httpResponseCode);
    }

    https.end();

    if (success)
      drawScreen();

    return success;
  }

  bool drawScreen()
  {
    display.clearDisplay();

    if (!isActive)
    {
      // Show the no active device screen
      display.drawBitmap(9, 8, no_active_device, 112, 49, 1);
      display.display();
      return true;
    }

    // Display content for active device
    display.setTextColor(SH110X_WHITE);
    display.setTextSize(1);

    // Truncate long strings
    String songName = truncateString(currentSong.song, 20);
    String artistName = truncateString(currentSong.artist, 20);

    // Display song info
    display.setCursor(0, 0);
    display.print(songName);

    display.setCursor(0, 15);
    display.print(artistName);

    // Draw progress bar
    int barY = 30;
    int barHeight = 8;
    int barWidth = map(currentSongPositionMs, 0, currentSong.durationMs, 0, SCREEN_WIDTH);

    display.drawRect(0, barY, SCREEN_WIDTH, barHeight, SH110X_WHITE);
    display.fillRect(0, barY, barWidth, barHeight, SH110X_WHITE);

    // Display play/pause state
    display.setCursor(45, 55);
    display.print(isPlaying ? "Playing" : "Paused");

    // Display volume
    display.setCursor(110, 55);
    display.print(volCtrl ? String(volume) : "N/A");

    display.display();
    return true;
  }

  bool togglePlay()
  {
    String url = "https://api.spotify.com/v1/me/player/";
    url += isPlaying ? "pause" : "play";

    https.begin(secureClient, url);
    https.addHeader("Authorization", "Bearer " + accessToken);
    https.addHeader("Content-Length", "0");

    int httpResponseCode = https.PUT("");
    bool success = (httpResponseCode == 204);

    if (success)
    {
      isPlaying = !isPlaying;
      Serial.println(isPlaying ? "Now playing" : "Now paused");
    }
    else
    {
      Serial.print("Error Toggling Playback: ");
      Serial.println(httpResponseCode);
      Serial.println(https.getString());
    }

    https.end();
    getTrackInfo();
    return success;
  }

  bool adjustVolume(int vol)
  {
    // Ensure volume is within valid range
    vol = constrain(vol, 0, 100);

    String url = "https://api.spotify.com/v1/me/player/volume?volume_percent=" + String(vol);

    https.begin(secureClient, url);
    https.addHeader("Authorization", "Bearer " + accessToken);
    https.addHeader("Content-Length", "0");

    int httpResponseCode = https.PUT("");
    bool success = (httpResponseCode == 204);

    if (success)
    {
      currVol = vol;
      Serial.println("Volume set to: " + String(vol));
    }
    else
    {
      Serial.print("Error setting volume: ");
      Serial.println(httpResponseCode);
      Serial.println(https.getString());
    }

    https.end();
    getTrackInfo();
    return success;
  }

  bool skipForward()
  {
    https.begin(secureClient, "https://api.spotify.com/v1/me/player/next");
    https.addHeader("Authorization", "Bearer " + accessToken);
    https.addHeader("Content-Length", "0");

    int httpResponseCode = https.POST("");
    bool success = (httpResponseCode == 204);

    if (success)
    {
      Serial.println("Skipped to next track");
    }
    else
    {
      Serial.print("Error skipping forward: ");
      Serial.println(httpResponseCode);
      Serial.println(https.getString());
    }

    https.end();
    getTrackInfo();
    return success;
  }

  bool skipBack()
  {
    https.begin(secureClient, "https://api.spotify.com/v1/me/player/previous");
    https.addHeader("Authorization", "Bearer " + accessToken);
    https.addHeader("Content-Length", "0");

    int httpResponseCode = https.POST("");
    bool success = (httpResponseCode == 204);

    if (success)
    {
      Serial.println("Skipped to previous track");
    }
    else
    {
      Serial.print("Error skipping backward: ");
      Serial.println(httpResponseCode);
      Serial.println(https.getString());
    }

    https.end();
    getTrackInfo();
    return success;
  }

  // Public variables
  bool accessTokenSet = false;
  unsigned long tokenStartTime;
  int tokenExpireTime;
  SongDetails currentSong;
  float currentSongPositionMs;
  float lastSongPositionMs;
  int currVol;
  bool isPlaying;
  bool isActive = false;
  bool volCtrl = false;
  int volume;

private:
  String accessToken;
  String refreshToken;
};

// Global Spotify Connection instance
SpotConn spotifyConnection;

// Helper function to truncate strings
String truncateString(const String &input, int maxLength)
{
  if (input.length() <= maxLength)
    return input;
  return input.substring(0, maxLength - 3) + "...";
}

// Web server handlers
void handleRoot()
{
  Serial.println("Handling root request");

  // Static buffer (safer than stack allocation)
  static char page[800]; // Increased to 800 for safety

  // Check if sprintf succeeds (prevents crashes)
  if (snprintf(page, sizeof(page), mainPage, CLIENT_ID, REDIRECT_URI) < 0)
  {
    server.send(500, "text/plain", "Failed to generate page");
    return;
  }

  server.send(200, "text/html", page); // Send directly (no String conversion)
}

void handleCallbackPage()
{
  if (!spotifyConnection.accessTokenSet)
  {
    if (server.arg("code") == "")
    {
      static char page[800];
      if (snprintf(page, sizeof(page), errorPage, CLIENT_ID, REDIRECT_URI) < 0)
      {
        server.send(500, "text/plain", "Error page failed");
        return;
      }
      server.send(200, "text/html", page);
    }
    else
    {
      if (spotifyConnection.getUserCode(server.arg("code")))
      {
        server.send(200, "text/plain",
                    "Spotify setup complete. Refresh in: " + String(spotifyConnection.tokenExpireTime));
      }
      else
      {
        static char page[800];
        if (snprintf(page, sizeof(page), errorPage, CLIENT_ID, REDIRECT_URI) < 0)
        {
          server.send(500, "text/plain", "Error page failed");
          return;
        }
        server.send(200, "text/html", page);
      }
    }
  }
  else
  {
    server.send(200, "text/plain", "Already authenticated");
  }
}

// Button handler function
void handleButtons()
{
  if (prevBtn.isPressed())
  {
    Serial.println("Previous button pressed");
    spotifyConnection.skipBack();
  }

  else if (playBtn.isPressed())
  {
    Serial.println("Play button pressed");
    spotifyConnection.togglePlay();
  }

  else if (nextBtn.isPressed())
  {
    Serial.println("Next button pressed");
    spotifyConnection.skipForward();
  }

  if (encSwBtn.isPressed())
  {
    Serial.println("Encoder switch pressed");
    spotifyConnection.togglePlay();
  }

  prevBtn.loop();
  playBtn.loop();
  nextBtn.loop();
  encSwBtn.loop();
}

// Volume control handler
void handleVolumeControl()
{
  if (spotifyConnection.volCtrl)
  {
    int newVolume = encoder.getCount() * 5;
    // Only update if volume change exceeds threshold
    if (abs(newVolume - spotifyConnection.currVol) > VOLUME_UPDATE_THRESHOLD)
    {
      spotifyConnection.adjustVolume(newVolume);
    }
  }
}

// Global flag for server state
bool serverOn = true;

void setup()
{
  // Initialize serial communication
  Serial.begin(9600);
  Serial.println("Starting ESP32 Spotify Player");

  // Initialize display
  delay(250); // Wait for OLED to initialize
  display.begin(I2C_ADDRESS, true);

  // Show splash screen
  display.clearDisplay();
  display.drawBitmap(9, 8, splash_screen, 112, 51, 1);
  display.display();
  delay(700);

  // Set up button pins
  pinMode(PLAY_BTN_PIN, INPUT_PULLUP);
  pinMode(PREV_BTN_PIN, INPUT_PULLUP);
  pinMode(NEXT_BTN_PIN, INPUT_PULLUP);
  pinMode(ENC_SW_PIN, INPUT_PULLUP);

  // Set up rotary encoder
  encoder.attachHalfQuad(ENC_DT_PIN, ENC_CLK_PIN);
  encoder.setCount(10); // Initial value

  // Connect to WiFi
  WiFi.begin(WIFI_SSID, PASSWORD);
  Serial.print("Connecting to WiFi");

  while (WiFi.status() != WL_CONNECTED)
  {
    delay(500);
    Serial.print(".");
  }

  Serial.println("\nConnected to WiFi");
  Serial.print("IP address: ");
  Serial.println(WiFi.localIP());

  // Set up web server
  server.on("/", handleRoot);
  server.on("/callback", handleCallbackPage);
  server.begin();
  Serial.println("HTTP server started");

  // Show configuration screen
  display.clearDisplay();
  display.setTextColor(1);
  display.setTextWrap(false);
  display.setCursor(5, 38);
  display.print("ESP IP:" + WiFi.localIP().toString());
  display.drawBitmap(14, 15, configuring, 102, 15, 1);
  display.display();
}

void loop()
{
  unsigned long currentMillis = millis();

  // If not authenticated, handle web server requests
  if (!spotifyConnection.accessTokenSet)
  {
    server.handleClient();
    return;
  }

  // Close server after authentication
  if (serverOn)
  {
    server.close();
    serverOn = false;
  }

  // Refresh access token if needed
  if ((currentMillis - spotifyConnection.tokenStartTime) / 1000 > spotifyConnection.tokenExpireTime - 60)
  {
    Serial.println("Refreshing token");
    if (spotifyConnection.refreshAuth())
    {
      Serial.println("Token refreshed successfully");
    }
  }

  // Update track info periodically
  if (currentMillis - lastApiRefresh > API_REFRESH_INTERVAL)
  {
    spotifyConnection.getTrackInfo();
    lastApiRefresh = currentMillis;
  }

  // Handle user input
  handleButtons();

  // Handle volume control
  handleVolumeControl();
}